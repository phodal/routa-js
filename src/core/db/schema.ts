/**
 * Drizzle ORM Schema — All tables for the Routa multi-agent system.
 *
 * Uses Neon Serverless Postgres (Vercel's recommended Postgres provider).
 * Every table uses `text` primary keys (UUIDs generated in JS) so that
 * agent/task/workspace IDs stay consistent across the MCP/ACP boundary.
 */

import {
  pgTable,
  text,
  timestamp,
  jsonb,
  integer,
  boolean,
  primaryKey,
} from "drizzle-orm/pg-core";

// ─── Workspaces ─────────────────────────────────────────────────────

export const workspaces = pgTable("workspaces", {
  id: text("id").primaryKey(),
  title: text("title").notNull(),
  status: text("status").notNull().default("active"),
  metadata: jsonb("metadata").$type<Record<string, string>>().default({}),
  createdAt: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(),
  updatedAt: timestamp("updated_at", { withTimezone: true }).notNull().defaultNow(),
});

// ─── Codebases ──────────────────────────────────────────────────────

export const codebases = pgTable("codebases", {
  id: text("id").primaryKey(),
  workspaceId: text("workspace_id").notNull().references(() => workspaces.id, { onDelete: "cascade" }),
  repoPath: text("repo_path").notNull(),
  branch: text("branch"),
  label: text("label"),
  isDefault: boolean("is_default").notNull().default(false),
  sourceType: text("source_type"),   // "local" | "github" — null treated as "local"
  sourceUrl: text("source_url"),     // e.g. "https://github.com/owner/repo"
  createdAt: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(),
  updatedAt: timestamp("updated_at", { withTimezone: true }).notNull().defaultNow(),
});

// ─── Agents ─────────────────────────────────────────────────────────

export const agents = pgTable("agents", {
  id: text("id").primaryKey(),
  name: text("name").notNull(),
  role: text("role").notNull(), // ROUTA | CRAFTER | GATE | DEVELOPER
  modelTier: text("model_tier").notNull().default("SMART"), // SMART | BALANCED | FAST
  workspaceId: text("workspace_id").notNull().references(() => workspaces.id, { onDelete: "cascade" }),
  parentId: text("parent_id"),
  status: text("status").notNull().default("PENDING"), // PENDING | ACTIVE | COMPLETED | ERROR | CANCELLED
  metadata: jsonb("metadata").$type<Record<string, string>>().default({}),
  createdAt: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(),
  updatedAt: timestamp("updated_at", { withTimezone: true }).notNull().defaultNow(),
});

// ─── Tasks ──────────────────────────────────────────────────────────

export const tasks = pgTable("tasks", {
  id: text("id").primaryKey(),
  title: text("title").notNull(),
  objective: text("objective").notNull(),
  scope: text("scope"),
  acceptanceCriteria: jsonb("acceptance_criteria").$type<string[]>(),
  verificationCommands: jsonb("verification_commands").$type<string[]>(),
  assignedTo: text("assigned_to"),
  status: text("status").notNull().default("PENDING"),
  dependencies: jsonb("dependencies").$type<string[]>().default([]),
  parallelGroup: text("parallel_group"),
  workspaceId: text("workspace_id").notNull().references(() => workspaces.id, { onDelete: "cascade" }),
  /** Session ID that created this task (for session-scoped filtering) */
  sessionId: text("session_id"),
  completionSummary: text("completion_summary"),
  verificationVerdict: text("verification_verdict"),
  verificationReport: text("verification_report"),
  /** Optimistic-locking version for atomic updates */
  version: integer("version").notNull().default(1),
  createdAt: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(),
  updatedAt: timestamp("updated_at", { withTimezone: true }).notNull().defaultNow(),
});

// ─── Notes ──────────────────────────────────────────────────────────

export const notes = pgTable(
  "notes",
  {
    id: text("id").notNull(),
    workspaceId: text("workspace_id").notNull().references(() => workspaces.id, { onDelete: "cascade" }),
    /** Session ID that created this note (for session-scoped grouping) */
    sessionId: text("session_id"),
    title: text("title").notNull(),
    content: text("content").notNull().default(""),
    type: text("type").notNull().default("general"), // spec | task | general
    taskStatus: text("task_status"),
    assignedAgentIds: jsonb("assigned_agent_ids").$type<string[]>(),
    parentNoteId: text("parent_note_id"),
    linkedTaskId: text("linked_task_id"),
    customMetadata: jsonb("custom_metadata").$type<Record<string, string>>(),
    createdAt: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(),
    updatedAt: timestamp("updated_at", { withTimezone: true }).notNull().defaultNow(),
  },
  (table) => [primaryKey({ columns: [table.workspaceId, table.id] })]
);

// ─── Messages (Conversation) ────────────────────────────────────────

export const messages = pgTable("messages", {
  id: text("id").primaryKey(),
  agentId: text("agent_id").notNull(),
  role: text("role").notNull(), // SYSTEM | USER | ASSISTANT | TOOL
  content: text("content").notNull(),
  timestamp: timestamp("timestamp", { withTimezone: true }).notNull().defaultNow(),
  toolName: text("tool_name"),
  toolArgs: text("tool_args"),
  turn: integer("turn"),
});

// ─── Event Subscriptions ────────────────────────────────────────────

export const eventSubscriptions = pgTable("event_subscriptions", {
  id: text("id").primaryKey(),
  agentId: text("agent_id").notNull(),
  agentName: text("agent_name").notNull(),
  eventTypes: jsonb("event_types").$type<string[]>().notNull(),
  excludeSelf: boolean("exclude_self").notNull().default(true),
  /** If true, auto-remove after first matching event delivery */
  oneShot: boolean("one_shot").notNull().default(false),
  /** Group ID for wait-all semantics */
  waitGroupId: text("wait_group_id"),
  /** Higher priority subscriptions are notified first */
  priority: integer("priority").notNull().default(0),
  createdAt: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(),
});

// ─── Pending Events (buffered for agent polling) ────────────────────

export const pendingEvents = pgTable("pending_events", {
  id: text("id").primaryKey(),
  agentId: text("agent_id").notNull(),
  eventType: text("event_type").notNull(),
  sourceAgentId: text("source_agent_id").notNull(),
  workspaceId: text("workspace_id").notNull(),
  data: jsonb("data").$type<Record<string, unknown>>().default({}),
  timestamp: timestamp("timestamp", { withTimezone: true }).notNull().defaultNow(),
});

// ─── ACP Sessions ─────────────────────────────────────────────────────

export interface AcpSessionNotification {
  sessionId: string;
  update?: Record<string, unknown>;
  [key: string]: unknown;
}

export const acpSessions = pgTable("acp_sessions", {
  id: text("id").primaryKey(),
  /** User-editable display name */
  name: text("name"),
  cwd: text("cwd").notNull(),
  workspaceId: text("workspace_id").notNull().references(() => workspaces.id, { onDelete: "cascade" }),
  routaAgentId: text("routa_agent_id"),
  provider: text("provider"),
  role: text("role"),
  modeId: text("mode_id"),
  /** Model used for this session */
  model: text("model"),
  /** Whether the first prompt has been sent */
  firstPromptSent: boolean("first_prompt_sent").default(false),
  /** Message history stored as JSONB array */
  messageHistory: jsonb("message_history").$type<AcpSessionNotification[]>().default([]),
  createdAt: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(),
  updatedAt: timestamp("updated_at", { withTimezone: true }).notNull().defaultNow(),
});

// ─── Traces ───────────────────────────────────────────────────────────

export const traces = pgTable("traces", {
  id: text("id").primaryKey(),
  sessionId: text("session_id").notNull(),
  workspaceId: text("workspace_id"),
  eventType: text("event_type").notNull(),
  version: text("version").notNull().default("0.1.0"),
  contributor: jsonb("contributor").$type<Record<string, unknown>>().notNull(),
  tool: jsonb("tool").$type<Record<string, unknown>>(),
  files: jsonb("files").$type<unknown[]>(),
  conversation: jsonb("conversation").$type<Record<string, unknown>>(),
  vcs: jsonb("vcs").$type<Record<string, unknown>>(),
  metadata: jsonb("metadata").$type<Record<string, unknown>>(),
  /** Original trace timestamp (ISO 8601) */
  timestamp: timestamp("timestamp", { withTimezone: true }).notNull(),
  createdAt: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(),
});

// ─── Skills ───────────────────────────────────────────────────────────

export interface SkillFileEntry {
  /** Relative path within the skill (e.g., "SKILL.md", "examples/usage.md") */
  path: string;
  /** File content */
  content: string;
}

export const skills = pgTable("skills", {
  /** Skill name (unique identifier, e.g., "mysql-best-practices") */
  id: text("id").primaryKey(),
  /** Human-readable name */
  name: text("name").notNull(),
  /** Short description extracted from SKILL.md frontmatter */
  description: text("description").notNull().default(""),
  /** Source repository (e.g., "mindrally/skills") */
  source: text("source").notNull(),
  /** Catalog type: "skillssh" | "github" | "local" */
  catalogType: text("catalog_type").notNull().default("skillssh"),
  /** All files in the skill directory, stored as JSON array */
  files: jsonb("files").$type<SkillFileEntry[]>().notNull().default([]),
  /** Optional license from SKILL.md frontmatter */
  license: text("license"),
  /** Additional metadata from SKILL.md frontmatter */
  metadata: jsonb("metadata").$type<Record<string, string>>().default({}),
  /** Installation count (for analytics) */
  installs: integer("installs").notNull().default(0),
  createdAt: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(),
  updatedAt: timestamp("updated_at", { withTimezone: true }).notNull().defaultNow(),
});

// ─── Workspace Skills (many-to-many) ────────────────────────────────

export const workspaceSkills = pgTable("workspace_skills", {
  workspaceId: text("workspace_id").notNull().references(() => workspaces.id, { onDelete: "cascade" }),
  skillId: text("skill_id").notNull().references(() => skills.id, { onDelete: "cascade" }),
  installedAt: timestamp("installed_at", { withTimezone: true }).notNull().defaultNow(),
}, (table) => [primaryKey({ columns: [table.workspaceId, table.skillId] })]);

// ─── Custom MCP Servers ───────────────────────────────────────────────────

export const customMcpServers = pgTable("custom_mcp_servers", {
  /** Unique identifier */
  id: text("id").primaryKey(),
  /** Human-readable name */
  name: text("name").notNull(),
  /** Short description */
  description: text("description"),
  /** MCP server type: "stdio" | "http" | "sse" */
  type: text("type").notNull(),
  /** Command to execute (for stdio type) */
  command: text("command"),
  /** Command arguments (for stdio type) */
  args: jsonb("args").$type<string[]>(),
  /** URL endpoint (for http/sse type) */
  url: text("url"),
  /** HTTP headers (for http/sse type) */
  headers: jsonb("headers").$type<Record<string, string>>(),
  /** Environment variables */
  env: jsonb("env").$type<Record<string, string>>(),
  /** Whether this server is enabled */
  enabled: boolean("enabled").notNull().default(true),
  /** Workspace scope (null = global) */
  workspaceId: text("workspace_id"),
  createdAt: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(),
  updatedAt: timestamp("updated_at", { withTimezone: true }).notNull().defaultNow(),
});

// ─── Background Tasks (async agent job queue) ─────────────────────────────

export const backgroundTasks = pgTable("background_tasks", {
  id: text("id").primaryKey(),
  /** Short human-readable title */
  title: text("title").notNull(),
  /** Full prompt to dispatch to the agent */
  prompt: text("prompt").notNull(),
  /** ACP agent/provider ID */
  agentId: text("agent_id").notNull(),
  workspaceId: text("workspace_id").notNull().references(() => workspaces.id, { onDelete: "cascade" }),
  /** PENDING | RUNNING | COMPLETED | FAILED | CANCELLED */
  status: text("status").notNull().default("PENDING"),
  /** Who triggered it (user ID or system) */
  triggeredBy: text("triggered_by").notNull().default("user"),
  /** manual | schedule | webhook | fleet */
  triggerSource: text("trigger_source").notNull().default("manual"),
  /** Task priority: HIGH | NORMAL | LOW */
  priority: text("priority").notNull().default("NORMAL"),
  /** ACP session created when the task starts */
  resultSessionId: text("result_session_id"),
  /** Error message when status = FAILED */
  errorMessage: text("error_message"),
  attempts: integer("attempts").notNull().default(0),
  maxAttempts: integer("max_attempts").notNull().default(1),
  startedAt: timestamp("started_at", { withTimezone: true }),
  completedAt: timestamp("completed_at", { withTimezone: true }),
  createdAt: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(),
  updatedAt: timestamp("updated_at", { withTimezone: true }).notNull().defaultNow(),
  // ─── Progress tracking fields ────────────────────────────────────────────
  /** Most recent activity timestamp */
  lastActivity: timestamp("last_activity", { withTimezone: true }),
  /** Current activity description */
  currentActivity: text("current_activity"),
  /** Number of tool calls executed */
  toolCallCount: integer("tool_call_count").default(0),
  /** Input tokens consumed */
  inputTokens: integer("input_tokens").default(0),
  /** Output tokens consumed */
  outputTokens: integer("output_tokens").default(0),
});

// ─── GitHub Webhook Configs ───────────────────────────────────────────────

/**
 * Stores user-configured GitHub webhook trigger rules.
 * Each row describes: which repo, which events, which agent to trigger.
 */
export const githubWebhookConfigs = pgTable("github_webhook_configs", {
  id: text("id").primaryKey(),
  /** Human-readable name for this trigger config */
  name: text("name").notNull(),
  /** GitHub repository in "owner/repo" format */
  repo: text("repo").notNull(),
  /** GitHub personal access token (stored encrypted/plaintext) */
  githubToken: text("github_token").notNull(),
  /** HMAC secret used to verify webhook payloads */
  webhookSecret: text("webhook_secret").notNull().default(""),
  /** GitHub event types to subscribe to, e.g. ["issues", "pull_request"] */
  eventTypes: jsonb("event_types").$type<string[]>().notNull().default([]),
  /** Optional label filter for issues.opened events */
  labelFilter: jsonb("label_filter").$type<string[]>().default([]),
  /** ACP agent/provider ID to trigger when event fires */
  triggerAgentId: text("trigger_agent_id").notNull(),
  /** Workspace scope */
  workspaceId: text("workspace_id"),
  /** Whether this config is active */
  enabled: boolean("enabled").notNull().default(true),
  /** Optional prompt template; {event} and {payload} are substituted */
  promptTemplate: text("prompt_template"),
  createdAt: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(),
  updatedAt: timestamp("updated_at", { withTimezone: true }).notNull().defaultNow(),
});

// ─── Schedules (cron-based agent triggers) ───────────────────────────────────

/**
 * Stores user-configured cron-based agent trigger rules.
 * Each row describes: which workspace, which cron expression, which agent to trigger.
 */
export const schedules = pgTable("schedules", {
  id: text("id").primaryKey(),
  /** Human-readable name for this schedule */
  name: text("name").notNull(),
  /** Cron expression, e.g. "0 2 * * *" (daily at 02:00 UTC) */
  cronExpr: text("cron_expr").notNull(),
  /** Full prompt to send when the schedule fires */
  taskPrompt: text("task_prompt").notNull(),
  /** ACP agent/provider ID to use (e.g. "claude-code") */
  agentId: text("agent_id").notNull(),
  /** Workspace scope */
  workspaceId: text("workspace_id").notNull().references(() => workspaces.id, { onDelete: "cascade" }),
  /** Whether this schedule is active */
  enabled: boolean("enabled").notNull().default(true),
  /** Timestamp of last successful trigger */
  lastRunAt: timestamp("last_run_at", { withTimezone: true }),
  /** Computed next trigger time (updated after each run) */
  nextRunAt: timestamp("next_run_at", { withTimezone: true }),
  /** Background task ID from the most recent trigger */
  lastTaskId: text("last_task_id"),
  /** Optional prompt template; {timestamp}, {cronExpr} are substituted */
  promptTemplate: text("prompt_template"),
  createdAt: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(),
  updatedAt: timestamp("updated_at", { withTimezone: true }).notNull().defaultNow(),
});

// ─── Webhook Trigger Logs ─────────────────────────────────────────────────

/**
 * Audit log for every GitHub webhook event received.
 */
export const webhookTriggerLogs = pgTable("webhook_trigger_logs", {
  id: text("id").primaryKey(),
  /** Config that matched this event */
  configId: text("config_id").notNull(),
  /** GitHub event type (e.g. "issues") */
  eventType: text("event_type").notNull(),
  /** GitHub event action (e.g. "opened") */
  eventAction: text("event_action"),
  /** Full payload (JSON) */
  payload: jsonb("payload").$type<Record<string, unknown>>().default({}),
  /** Background task created, if any */
  backgroundTaskId: text("background_task_id"),
  /** Whether signature verification passed */
  signatureValid: boolean("signature_valid").notNull().default(false),
  /** Processing outcome: "triggered" | "skipped" | "error" */
  outcome: text("outcome").notNull().default("triggered"),
  /** Error message if outcome = "error" */
  errorMessage: text("error_message"),
  createdAt: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(),
});

// ─── Specialists (user-defined agent specialist configurations) ───────────

export const specialists = pgTable("specialists", {
  /** Unique identifier (e.g., "routa", "crafter", or custom ID) */
  id: text("id").primaryKey(),
  /** Human-readable name */
  name: text("name").notNull(),
  /** Short description */
  description: text("description").notNull().default(""),
  /** Source of this specialist: "user" | "bundled" | "hardcoded" */
  source: text("source").notNull().default("user"),
  /** Agent role: "ROUTA" | "CRAFTER" | "GATE" | "DEVELOPER" */
  role: text("role").notNull(),
  /** Default model tier: "FAST" | "BALANCED" | "SMART" */
  defaultModelTier: text("default_model_tier").notNull().default("SMART"),
  /** System prompt / behavior prompt */
  systemPrompt: text("system_prompt").notNull(),
  /** Short role reminder */
  roleReminder: text("role_reminder").notNull().default(""),
  /** Optional specific model override */
  model: text("model"),
  /** Whether this specialist is enabled */
  enabled: boolean("enabled").notNull().default(true),
  /** Created by user ID (for future multi-tenant support) */
  createdBy: text("created_by"),
  /** Creation timestamp */
  createdAt: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(),
  /** Last update timestamp */
  updatedAt: timestamp("updated_at", { withTimezone: true }).notNull().defaultNow(),
});

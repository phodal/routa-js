/**
 * Browser ACP Client
 *
 * Connects to `/api/acp` via JSON-RPC over HTTP and receives `session/update`
 * notifications via SSE.
 *
 * The backend spawns an opencode process per session and proxies:
 *   - JSON-RPC requests → opencode stdin
 *   - opencode stdout → SSE session/update
 */

export interface AcpSessionNotification {
  sessionId: string;
  update?: Record<string, unknown>;
  /** Flat fields from opencode (sessionUpdate, content, etc.) */
  [key: string]: unknown;
}

export interface AcpInitializeResult {
  protocolVersion: string | number;
  agentCapabilities: Record<string, unknown>;
  agentInfo?: { name: string; version: string };
}

export interface AcpNewSessionResult {
  sessionId: string;
  provider?: string;
  role?: string;
  routaAgentId?: string;
}

export interface AcpPromptResult {
  stopReason: string;
  /** Full response content (for serverless environments where SSE may not work) */
  content?: string;
  /** Token usage info */
  usage?: {
    inputTokens?: number;
    outputTokens?: number;
  };
}

export interface AcpProviderInfo {
  id: string;
  name: string;
  description: string;
  command: string;
  status?: "available" | "unavailable" | "checking";
  source?: "static" | "registry";
}

export type SessionUpdateHandler = (update: AcpSessionNotification) => void;

/**
 * Authentication method info from ACP agent.
 */
export interface AcpAuthMethod {
  id: string;
  name: string;
  description: string;
}

/**
 * Custom error class for ACP errors that may include auth requirements.
 */
export class AcpClientError extends Error {
  code: number;
  authMethods?: AcpAuthMethod[];
  agentInfo?: { name: string; version: string };

  constructor(
    message: string,
    code: number,
    authMethods?: AcpAuthMethod[],
    agentInfo?: { name: string; version: string }
  ) {
    super(message);
    this.name = "AcpClientError";
    this.code = code;
    this.authMethods = authMethods;
    this.agentInfo = agentInfo;
  }
}

export class BrowserAcpClient {
  private baseUrl: string;
  private eventSource: EventSource | null = null;
  private updateHandlers: SessionUpdateHandler[] = [];
  private requestId = 0;
  private _sessionId: string | null = null;

  constructor(baseUrl: string = "") {
    this.baseUrl = baseUrl;
  }

  get sessionId(): string | null {
    return this._sessionId;
  }

  /**
   * Initialize the ACP connection.
   */
  async initialize(
    protocolVersion: number | string = 1
  ): Promise<AcpInitializeResult> {
    return this.rpc("initialize", { protocolVersion });
  }

  /**
   * Create a new ACP session.
   * This spawns a new ACP agent process on the backend.
   *
   * @param params.idempotencyKey - Optional unique key to prevent duplicate session creation.
   *   If provided, the backend will return the same session for repeated requests with the same key
   *   within a short time window (30 seconds). This prevents multiple sessions being created when
   *   user clicks "Start" multiple times before navigation completes.
   */
  async newSession(params: {
    cwd?: string;
    provider?: string;
    modeId?: string;
    role?: string;
    crafterProvider?: string;
    gateProvider?: string;
    mcpServers?: Array<{ name: string; url?: string }>;
    workspaceId?: string;
    model?: string;
    idempotencyKey?: string;
    specialistId?: string;
    /** Custom API base URL (overrides ANTHROPIC_BASE_URL env var) */
    baseUrl?: string;
    /** API key override (overrides ANTHROPIC_AUTH_TOKEN env var) */
    apiKey?: string;
  }): Promise<AcpNewSessionResult> {
    const result = await this.rpc<AcpNewSessionResult>("session/new", {
      cwd: params.cwd,
      provider: params.provider ?? "opencode",
      modeId: params.modeId,
      role: params.role,
      crafterProvider: params.crafterProvider,
      gateProvider: params.gateProvider,
      mcpServers: params.mcpServers ?? [],
      workspaceId: params.workspaceId,
      model: params.model,
      idempotencyKey: params.idempotencyKey,
      specialistId: params.specialistId,
      baseUrl: params.baseUrl,
      apiKey: params.apiKey,
    });
    this._sessionId = result.sessionId;

    // Connect SSE after we know the sessionId
    this.attachSession(result.sessionId);

    return result;
  }

  /**
   * List available models for a provider (e.g. opencode).
   */
  async listProviderModels(provider: string): Promise<string[]> {
    const response = await fetch(`${this.baseUrl}/api/providers/models?provider=${encodeURIComponent(provider)}`);
    const data = await response.json();
    return Array.isArray(data.models) ? data.models : [];
  }

  /**
   * List available ACP providers from the backend.
   * @param check - If true, check command availability (slower). If false, return immediately with "checking" status.
   * @param includeRegistry - If true, include registry providers (slower). If false, only local providers.
   */
  async listProviders(check: boolean = false, includeRegistry: boolean = false): Promise<AcpProviderInfo[]> {
    const params = new URLSearchParams();
    if (check) params.set("check", "true");
    if (includeRegistry) params.set("registry", "true");

    const response = await fetch(`${this.baseUrl}/api/providers?${params}`);
    const data = await response.json();

    return Array.isArray(data.providers) ? data.providers : [];
  }

  /**
   * Load registry providers asynchronously after local providers are loaded.
   * This is useful for showing local providers first, then loading registry in background.
   */
  async loadRegistryProviders(): Promise<AcpProviderInfo[]> {
    const response = await fetch(`${this.baseUrl}/api/providers?registry=true`);
    const data = await response.json();
    return Array.isArray(data.providers) ? data.providers : [];
  }

  /**
   * Attach to an existing session ID (switch sessions).
   */
  attachSession(sessionId: string): void {
    this._sessionId = sessionId;
    this.connectSSE(sessionId);
  }

  /**
   * Send a prompt to the session.
   * Content streams via SSE session/update notifications.
   * In serverless environments, the POST response itself streams SSE events.
   *
   * @param sessionId - The session to send to
   * @param text - The prompt text
   * @param skillContext - Optional skill context (name + content) from UI /skill selection
   */
  async prompt(
    sessionId: string,
    text: string,
    skillContext?: { skillName: string; skillContent: string },
  ): Promise<AcpPromptResult> {
    const id = ++this.requestId;

    const params: Record<string, unknown> = {
      sessionId,
      prompt: [{ type: "text", text }],
    };

    // Pass skill context so the backend can inject it via appendSystemPrompt (SDK)
    // or prepend to prompt (CLI) for proper skill integration
    if (skillContext) {
      params.skillName = skillContext.skillName;
      params.skillContent = skillContext.skillContent;
    }

    const response = await fetch(`${this.baseUrl}/api/acp`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        jsonrpc: "2.0",
        id,
        method: "session/prompt",
        params,
      }),
    });

    const contentType = response.headers.get("Content-Type") || "";

    // Handle streaming SSE response (serverless environments)
    if (contentType.includes("text/event-stream")) {
      return this.handleStreamingPromptResponse(response, sessionId);
    }

    // Handle traditional JSON response
    const data = await response.json();
    if (data.error) {
      throw new AcpClientError(
        data.error.message,
        data.error.code,
        data.error.authMethods,
        data.error.agentInfo
      );
    }

    const result = data.result as AcpPromptResult;

    // Legacy fallback: if response includes content directly, emit as notification
    if (result.content) {
      const notification: AcpSessionNotification = {
        sessionId,
        update: {
          sessionUpdate: "agent_message_chunk",
          content: { type: "text", text: result.content },
        },
      };
      for (const handler of this.updateHandlers) {
        try { handler(notification); } catch (err) { console.error("[AcpClient] Handler error:", err); }
      }

      const turnCompleteNotification: AcpSessionNotification = {
        sessionId,
        update: {
          sessionUpdate: "turn_complete",
          stopReason: result.stopReason,
          usage: result.usage ? {
            input_tokens: result.usage.inputTokens,
            output_tokens: result.usage.outputTokens,
          } : undefined,
        },
      };
      for (const handler of this.updateHandlers) {
        try { handler(turnCompleteNotification); } catch (err) { console.error("[AcpClient] Handler error:", err); }
      }
    }

    return result;
  }

  /**
   * Handle streaming SSE response from prompt endpoint.
   * Reads SSE events from the response body and dispatches notifications.
   */
  private async handleStreamingPromptResponse(
    response: Response,
    sessionId: string
  ): Promise<AcpPromptResult> {
    const reader = response.body?.getReader();
    if (!reader) {
      throw new Error("Response body is not readable");
    }

    const decoder = new TextDecoder();
    let buffer = "";
    let lastStopReason = "end_turn";
    let lastUsage: { inputTokens: number; outputTokens: number } | undefined;

    try {
      while (true) {
        const { done, value } = await reader.read();
        if (done) break;

        buffer += decoder.decode(value, { stream: true });

        // Process complete SSE events (lines ending with \n\n)
        const lines = buffer.split("\n\n");
        buffer = lines.pop() || ""; // Keep incomplete event in buffer

        for (const line of lines) {
          if (!line.startsWith("data: ")) continue;

          try {
            const jsonStr = line.slice(6); // Remove "data: " prefix
            const data = JSON.parse(jsonStr);

            // Dispatch notification to handlers
            if (data.method === "session/update" && data.params) {
              const notification = data.params as AcpSessionNotification;

              // Track turn_complete for return value
              const update = notification.update as Record<string, unknown> | undefined;
              if (update?.sessionUpdate === "turn_complete") {
                lastStopReason = (update.stopReason as string) || "end_turn";
                const usage = update.usage as Record<string, number> | undefined;
                if (usage) {
                  lastUsage = {
                    inputTokens: usage.input_tokens || 0,
                    outputTokens: usage.output_tokens || 0,
                  };
                }
              }

              for (const handler of this.updateHandlers) {
                try {
                  handler(notification);
                } catch (err) {
                  console.error("[AcpClient] Handler error:", err);
                }
              }
            }
          } catch (parseErr) {
            console.error("[AcpClient] SSE parse error:", parseErr);
          }
        }
      }
    } finally {
      reader.releaseLock();
    }

    return {
      stopReason: lastStopReason,
      usage: lastUsage,
    };
  }

  /**
   * Set session mode (if provider supports it).
   */
  async setMode(sessionId: string, modeId: string): Promise<void> {
    await this.rpc("session/set_mode", { sessionId, modeId });
  }

  /**
   * Cancel the current prompt.
   */
  async cancel(sessionId: string): Promise<void> {
    await this.rpc("session/cancel", { sessionId });
  }

  /**
   * Register a handler for session updates (SSE).
   */
  onUpdate(handler: SessionUpdateHandler): () => void {
    this.updateHandlers.push(handler);
    return () => {
      this.updateHandlers = this.updateHandlers.filter((h) => h !== handler);
    };
  }

  /**
   * Disconnect and clean up.
   */
  disconnect(): void {
    if (this.eventSource) {
      this.eventSource.close();
      this.eventSource = null;
    }
    this._sessionId = null;
    this.updateHandlers = [];
  }

  // ─── Private ─────────────────────────────────────────────────────────

  private connectSSE(sessionId: string): void {
    if (this.eventSource) {
      this.eventSource.close();
    }

    this.eventSource = new EventSource(
      `${this.baseUrl}/api/acp?sessionId=${sessionId}`
    );

    this.eventSource.onmessage = (event) => {
      try {
        const data = JSON.parse(event.data);
        if (data.method === "session/update" && data.params) {
          const notification = data.params as AcpSessionNotification;

          for (const handler of this.updateHandlers) {
            try {
              handler(notification);
            } catch (err) {
              console.error("[AcpClient] Handler error:", err);
            }
          }
        }
      } catch (err) {
        console.error("[AcpClient] SSE parse error:", err);
      }
    };

    this.eventSource.onerror = () => {
      // SSE will auto-reconnect
    };
  }

  private async rpc<T = unknown>(
    method: string,
    params: Record<string, unknown>
  ): Promise<T> {
    const id = ++this.requestId;

    const response = await fetch(`${this.baseUrl}/api/acp`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        jsonrpc: "2.0",
        id,
        method,
        params,
      }),
    });

    const data = await response.json();

    if (data.error) {
      // Throw AcpClientError with auth info if available
      throw new AcpClientError(
        data.error.message,
        data.error.code,
        data.error.authMethods,
        data.error.agentInfo
      );
    }

    return data.result as T;
  }
}

Now I have a comprehensive understanding. Here's the full analysis:

---

## Collaborative Tasks Feature — Architecture Deep Dive

### 1. File Map

| Layer | File | Purpose |
|-------|------|---------|
| **Models** | [src/core/models/note.ts](src/core/models/note.ts) | `Note` interface, `NoteType` ("spec" / "task" / "general"), `NoteMetadata` with `taskStatus`, `assignedAgentIds`, `linkedTaskId` |
| **Models** | [src/core/models/task.ts](src/core/models/task.ts) | `Task` interface with `TaskStatus` enum |
| **Stores** | [src/core/store/note-store.ts](src/core/store/note-store.ts) | `NoteStore` interface + `InMemoryNoteStore` — keyed by `${workspaceId}:${noteId}` |
| **Stores** | [src/core/store/task-store.ts](src/core/store/task-store.ts) | `TaskStore` interface + `InMemoryTaskStore` — dependency-aware `findReadyTasks()` |
| **Tools** | [src/core/tools/note-tools.ts](src/core/tools/note-tools.ts) | `NoteTools` class — MCP-exposed CRUD + `setNoteContent` + `convertTaskBlocks` |
| **Orchestration** | [src/core/orchestration/task-block-parser.ts](src/core/orchestration/task-block-parser.ts) | Server-side `@@@task` block parser (extracts title, sections via `##` headings) |
| **MCP Executor** | [src/core/mcp/mcp-tool-executor.ts](src/core/mcp/mcp-tool-executor.ts) | Routes `set_note_content` → `noteTools.setNoteContent()` |
| **Broadcasting** | [src/core/notes/note-event-broadcaster.ts](src/core/notes/note-event-broadcaster.ts) | `NoteEventBroadcaster` singleton — broadcasts `note:created / note:updated / note:deleted` via SSE |
| **API** | [src/app/api/notes/route.ts](src/app/api/notes/route.ts) | REST endpoints: GET list/fetch, POST create/update, DELETE |
| **API** | [src/app/api/notes/events/route.ts](src/app/api/notes/events/route.ts) | SSE endpoint for real-time note change events |
| **API** | [src/app/api/acp/route.ts](src/app/api/acp/route.ts) | Session creation (`session/new`), CRAFTER agent spawning, ROUTA orchestration registration |
| **Hook** | [src/client/hooks/use-notes.ts](src/client/hooks/use-notes.ts) | `useNotes()` — fetch, CRUD, SSE subscription with auto-reconnect |
| **Hook** | [src/client/hooks/use-acp.ts](src/client/hooks/use-acp.ts) | `useAcp()` — ACP client lifecycle, session management, prompt sending |
| **Component** | [src/client/components/collaborative-task-editor.tsx](src/client/components/collaborative-task-editor.tsx) | `CollaborativeTaskEditor` — real-time task list with inline editing, CRDT badge, concurrency control |
| **Component** | [src/client/components/task-panel.tsx](src/client/components/task-panel.tsx) | `TaskPanel` + `CraftersView` — displays parsed `@@@task` blocks and CRAFTER agent chat histories |
| **Utility** | [src/client/utils/task-block-parser.ts](src/client/utils/task-block-parser.ts) | Client-side `@@@task` parser (for chat panel detection) |
| **Page** | [src/app/[workspaceId]/[sessionId]/session-page-client.tsx](src/app/%5BworkspaceId%5D/%5BsessionId%5D/session-page-client.tsx) | Main session page — wires everything together |

---

### 2. How `set_note_content` Works

The flow is:

1. **Agent calls MCP tool** `set_note_content` with `{noteId, content, title?, workspaceId}`
2. **[MCP tool executor](src/core/mcp/mcp-tool-executor.ts#L205)** routes to `noteTools.setNoteContent()`
3. **[NoteTools.setNoteContent()](src/core/tools/note-tools.ts#L108)** does:
   - Fetches the note from `NoteStore` (auto-creates if `noteId === "spec"`)
   - Updates `content`, optionally `title`, sets `updatedAt`
   - Saves via `NoteStore.save()` (which calls the broadcaster in CRDT stores)
   - **Auto-converts `@@@task` blocks**: If the note is the spec note (or `autoConvertTasks` is true), it calls `convertTaskBlocks()`:
     - Parses `@@@task` blocks using the [server-side parser](src/core/orchestration/task-block-parser.ts)
     - For each parsed task: creates a `Task` record in `TaskStore` + a `Note` of type `"task"` in `NoteStore`
     - Replaces `@@@task` blocks in the source note with `- [ ] [Title](task://noteId)` links
   - Returns `{ noteId, tasksCreated, tasks: [{taskId, noteId, title}] }`

4. **The API route** [/api/notes POST](src/app/api/notes/route.ts) calls `system.noteBroadcaster.notifyUpdated()` to broadcast to all SSE clients
5. **Client `useNotes` hook** [receives SSE events](src/client/hooks/use-notes.ts#L214) and updates React state

---

### 3. Session Creation and Storage

**Session creation flow** in [/api/acp route.ts](src/app/api/acp/route.ts#L145):

1. Client calls `acp.createSession()` via the `useAcp` hook → JSON-RPC `session/new`
2. ACP route determines provider type (claude-code-sdk, claude CLI, or standard ACP)
3. Spawns the appropriate agent process via `AcpProcessManager`
4. For **ROUTA role**: additionally creates an orchestrator agent record, registers notification/session handlers
5. Persists session to `HttpSessionStore.upsertSession()` (in-memory for dev, plus Postgres for serverless)
6. Supports **idempotency keys** to prevent duplicate sessions
7. Returns `{sessionId, provider, role, routaAgentId}`

**CRAFTER sessions** are created during task delegation (not directly by users):
- `handleExecuteTask` / `handleExecuteNoteTask` calls MCP tool `delegate_task_to_agent` with `specialist: "CRAFTER"`
- The orchestrator spawns a child session with role `"CRAFTER"` ([line 458](src/app/api/acp/route.ts#L458))
- A `CrafterAgent` object is created client-side with `{id, sessionId, taskId, taskTitle, status, messages[]}`

**Storage is primarily in-memory** — `InMemoryNoteStore`, `InMemoryTaskStore`, `HttpSessionStore`. Postgres persistence exists as a seconday store for serverless environments.

---

### 4. How Collaborative Tasks Are Displayed

The right sidebar in [session-page-client.tsx](src/app/%5BworkspaceId%5D/%5BsessionId%5D/session-page-client.tsx#L1342) conditionally renders:

```tsx
{hasCollabNotes ? (
  <CollaborativeTaskEditor ... />   // Notes-backed tasks
) : (
  <TaskPanel ... />                 // Parsed @@@task blocks from chat
)}
```

**Two paths** for task display:

| Path | Source | Component | Trigger |
|------|--------|-----------|---------|
| **Notes-backed** | `useNotes()` SSE stream | `CollaborativeTaskEditor` | When agent calls `set_note_content` creating task notes |
| **Chat-parsed** | `@@@task` blocks in agent response | `TaskPanel` | When chat panel detects `@@@task` blocks via client-side parser |

The `CollaborativeTaskEditor` shows:
- **Header**: task count, "Execute All" button, live/offline indicator, CRDT badge
- **Concurrency control**: toggle between 1 and 2 parallel agents
- **Spec note** (collapsible): the spec document with markdown rendering
- **Task cards**: each with status icon (PENDING/IN_PROGRESS/COMPLETED/FAILED), title, content sections (Objective/Scope/Inputs/Outputs/Definition of Done), inline editor with debounced auto-save
- **CRAFTERs view**: tabs for each spawned CRAFTER agent with streaming chat history

---

### 5. Concurrency Implementation

Concurrency is managed in [session-page-client.tsx](src/app/%5BworkspaceId%5D/%5BsessionId%5D/session-page-client.tsx):

**State**: `const [concurrency, setConcurrency] = useState(1);` — UI toggle between 1 and 2.

**Execution** (`handleExecuteAllNoteTasks` at [line 949](src/app/%5BworkspaceId%5D/%5BsessionId%5D/session-page-client.tsx#L949)):

```typescript
if (effectiveConcurrency <= 1) {
  // Sequential: await each task one by one
  for (const note of pendingNotes) {
    const agent = await handleExecuteNoteTask(note.id);
    if (agent) setActiveCrafterId(agent.id);
  }
} else {
  // Parallel: process in batches of `effectiveConcurrency`
  const queue = [...pendingNotes];
  while (queue.length > 0) {
    const batch = queue.splice(0, effectiveConcurrency);
    const results = await Promise.allSettled(
      batch.map((n) => handleExecuteNoteTask(n.id))
    );
    // Select first successful agent from batch
  }
}
```

The same pattern exists for `handleExecuteAllTasks` (the chat-parsed path). The concurrency is capped at `Math.min(requestedConcurrency, items.length)`.

**Per-task execution** (`handleExecuteNoteTask`):
1. Mark note as `IN_PROGRESS`
2. Call MCP `create_task` → get `mcpTaskId`
3. Call MCP `delegate_task_to_agent` → get `agentId` + `childSessionId`
4. Create `CrafterAgent` record locally
5. Child agent updates stream via SSE → routed to the correct `CrafterAgent.messages[]` array

---

### 6. State Management Patterns

| Pattern | Usage |
|---------|-------|
| **React hooks (useState/useCallback)** | All state in `SessionPageClient` — `routaTasks`, `crafterAgents`, `activeCrafterId`, `concurrency`, `taskPanelMode` |
| **Custom hooks** | `useNotes()` — encapsulates fetch + SSE + CRUD; `useAcp()` — encapsulates ACP client lifecycle; `useWorkspaces()`; `useSkills()` |
| **SSE (Server-Sent Events)** | Real-time note updates via `NoteEventBroadcaster` + `EventSource` in `useNotes`; ACP session updates via `BrowserAcpClient.onUpdate()` |
| **Refs for cross-render state** | `mcpSessionRef` (MCP session ID), `lastChildUpdateIndexRef` (incremental SSE update processing), `sessionMetadataLoadedRef` (dedup), `pendingPromptSentRef` |
| **Singleton stores** | `InMemoryNoteStore`, `InMemoryTaskStore`, `NoteEventBroadcaster` — global instances via `getRoutaSystem()` and `getNoteEventBroadcaster()` |
| **No external state lib** | No Redux/Zustand/Jotai — all state is local React state lifted to the page component and passed as props |
| **Prop drilling** | `SessionPageClient` passes callbacks/state down to `CollaborativeTaskEditor`, `TaskPanel`, `CraftersView`, `ChatPanel` |

The architecture follows a **hub-and-spoke** pattern where `SessionPageClient` is the central hub coordinating between all subsystems (ACP sessions, MCP tools, Notes SSE, task execution).